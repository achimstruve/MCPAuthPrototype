# =============================================================================
# externalsecret.yaml - Sync JWT Signing Key from GCP Secret Manager
# =============================================================================
#
# An ExternalSecret tells ESO WHICH specific secret to fetch and how to
# create the Kubernetes Secret from it. While the SecretStore defines the
# connection (HOW to reach GCP), this resource defines the mapping
# (WHAT to sync).
#
# The complete secret injection chain:
#
#   GCP Secret Manager
#   └── Secret: "mcp-jwt-signing-key" (the actual signing key value)
#         │
#         │  ESO reads via SecretStore (using Workload Identity)
#         ▼
#   ExternalSecret (this resource)
#   └── Creates K8s Secret: "mcp-jwt-secret"
#       └── Key: "jwt-signing-key" = <value from GCP>
#             │
#             │  Deployment references via secretKeyRef
#             ▼
#   Pod environment variable: MCP_JWT_SECRET_KEY = <value>
#
# What happens at runtime:
# 1. helm install creates this ExternalSecret resource
# 2. ESO's controller detects the new ExternalSecret
# 3. ESO reads the SecretStore to know how to connect to GCP
# 4. ESO calls GCP Secret Manager API to fetch the secret value
# 5. ESO creates a native K8s Secret with the fetched value
# 6. The Deployment's pod spec references this K8s Secret
# 7. Kubernetes injects the secret value as an environment variable
#
# Note: Steps 2-5 take a few seconds. Pods may briefly show
# "CreateContainerConfigError" until the K8s Secret exists. This is normal.
# =============================================================================

{{- if .Values.externalSecret.enabled }}
apiVersion: external-secrets.io/v1
kind: ExternalSecret
metadata:
  name: {{ include "mcp-server.fullname" . }}-jwt
  labels:
    {{- include "mcp-server.labels" . | nindent 4 }}
spec:
  # How often ESO re-checks GCP Secret Manager for changes.
  # If you rotate the JWT signing key in GCP, ESO will pick up the new
  # value within this interval and update the K8s Secret automatically.
  # Pods will get the new value on their next restart.
  refreshInterval: {{ .Values.externalSecret.refreshInterval }}

  # Reference to the SecretStore that defines the GCP connection
  secretStoreRef:
    name: {{ .Values.externalSecret.secretStore }}
    kind: SecretStore

  # Configuration for the K8s Secret that ESO will create
  target:
    # Name of the K8s Secret to create
    name: {{ .Values.externalSecret.secretName }}
    # Owner: If this ExternalSecret is deleted, the K8s Secret is also
    # deleted (garbage collection). This prevents orphaned secrets.
    creationPolicy: Owner

  # Mapping: which remote secret → which key in the K8s Secret
  data:
    - secretKey: {{ .Values.externalSecret.secretKey }}
      remoteRef:
        # The name of the secret in GCP Secret Manager
        key: {{ .Values.externalSecret.remoteRef }}
        # Omitting "version" defaults to "latest" — always gets the
        # most recent version of the secret. You could pin to a specific
        # version for stability: version: "1"
{{- end }}
